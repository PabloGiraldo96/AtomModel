<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@200&family=Poppins:wght@300&display=swap" rel="stylesheet">
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
	<script type="importmap">
		{
			"imports": {
				"three": "https://unpkg.com/three/build/three.module.js"
			}
		}
	</script>
	<title>3D Atom Example</title>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
</head>
<body id="body">
<div class="canvas container" >

<script type="module"> 

import * as THREE from './orbitControls/three.module.js';
import {OrbitControls} from './orbitControls/OrbitControls.js'

//Vertices del cubo

		const verticesOfCube = [
			-1,-1,-1,    1,-1,-1,    1, 1,-1,    -1, 1,-1,
			-1,-1, 1,    1,-1, 1,    1, 1, 1,    -1, 1, 1,
		];

		const indicesOfFaces = [
			2,1,0,    0,3,2,
			0,4,7,    7,3,0,
			0,1,5,    5,4,0,
			1,2,6,    6,5,1,
			2,3,7,    7,6,2,
			4,5,6,    6,7,4
		];

		const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
		camera.position.set(15, 12, -22)

		const scene = new THREE.Scene();

		const renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setAnimationLoop( animation );
		document.body.appendChild( renderer.domElement );

		window.addEventListener('resize', function(){
		let width = window.innerWidth;
		let height = window.innerHeight;
		renderer.setSize(width, height);
		camera.aspect = width / height;
		camera.updateProjectionMatrix();
	});


		//Orbit Controls 

		const controls = new OrbitControls( camera, renderer.domElement );
		controls.minDistance = 20;
		controls.maxDistance = 20;

        // Crear una geometría y un material

		const planeGeometry = new THREE.PlaneGeometry(20, 20);
		const planeMaterial = new THREE.MeshBasicMaterial({side: true, visible: false});
		
		const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
		planeMesh.rotateX(-Math.PI / 2);


		const grid = new THREE.GridHelper(40, 40);
		scene.add(grid, planeMesh);

		const gridGeometry = grid.geometry;
		const originalPositions = gridGeometry.attributes.position.array.slice();

		// DEFORMAR GRID

		function deformGrid(time) {
			const factor = 0.3; // Ajusta este factor según tu preferencia de deformación
			const positions = gridGeometry.attributes.position.array;

			// Modifica las posiciones de los vértices para deformar el GridHelper
			for (let i = 0; i < positions.length; i += 3) {
				const x = originalPositions[i];
				const y = originalPositions[0];
				const z = originalPositions[i + 3];

				// Aplica una deformación sinusoidal en la dirección y
				positions[i + 1] = y + Math.sin(x * factor + time / 800) * 4;
			}

			// Actualiza los datos de la geometría
			gridGeometry.attributes.position.needsUpdate = true;
		}

		const geometrySphere = new THREE.SphereGeometry(0.0050, 32, 32);
		const materialSphere = new THREE.MeshNormalMaterial();

		const sphere = new THREE.Mesh(geometrySphere, materialSphere);
		//scene.add(sphere);

		const geometryOne = new THREE.PolyhedronGeometry( verticesOfCube, indicesOfFaces, 0.2, 32 );
		const materialOne = new THREE.MeshMatcapMaterial({specular:0xFFFFFF,shininess: 30 });

		const matcapTextureone = new THREE.TextureLoader().load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRzjFpBMnkh1WTUYftvzeJRu9r7P2mB4PmQBA&usqp=CAU');
		materialOne.matcap = matcapTextureone;

		const torus = new THREE.Mesh( geometryOne, materialOne );
		scene.add( torus );

		const geometry = new THREE.PolyhedronGeometry( verticesOfCube, indicesOfFaces, 0.6, 32 );
		const material = new THREE.MeshStandardMaterial({
		roughness: 0,
		metalness: 0.2,
		color: 0xFFFA20,
		specular: 0xFFFFFF,
		shininess: 30,
        });

		const matcapTexture = new THREE.TextureLoader().load('https://png.pngtree.com/thumb_back/fh260/background/20201104/pngtree-hologram-color-mix-background-image_457908.jpg');
		material.matcap = matcapTexture;

		const mesh = new THREE.Mesh( geometry, materialOne );

		const geometryone = new THREE.PolyhedronGeometry( verticesOfCube, indicesOfFaces, 0.2, 32 );
		const materialone = new THREE.MeshNormalMaterial({specular:0xFFFFFF,shininess: 30 });
		const torusOne= new THREE.Mesh( geometryone, materialOne);

		const geometryFour = new THREE.PolyhedronGeometry( verticesOfCube, indicesOfFaces, 0.2, 32 );
		const materialfour = new THREE.MeshDepthMaterial({specular:0xFFFFFF,shininess: 30 });
		const torusThree= new THREE.Mesh( geometryFour, materialOne);

		const geometryFive = new THREE.PolyhedronGeometry( verticesOfCube, indicesOfFaces, 0.2, 32 );
		const materialfive = new THREE.MeshDepthMaterial({specular:0xFFFFFF,shininess: 30 });
		const torusFive= new THREE.Mesh( geometryFive, materialOne);

		const geometrySix = new THREE.PolyhedronGeometry( verticesOfCube, indicesOfFaces, 0.2, 32 );
		const materialSix = new THREE.MeshDepthMaterial({specular:0xFFFFFF,shininess: 30 });
		const torusSix= new THREE.Mesh( geometryFive, materialOne);

		const geometrySeven = new THREE.PolyhedronGeometry( verticesOfCube, indicesOfFaces, 0.2, 32 );
		const materialSeven = new THREE.MeshDepthMaterial({specular:0xFFFFFF,shininess: 30 });
		const torusSeven= new THREE.Mesh( geometrySeven, materialOne);

		scene.add( mesh,torusOne,torusThree,torusFive, torusSix, torusSeven );

	// animation

	mesh.position.y = 0.5;
	mesh.position.z = 0;


	function animation(time){

	const radius = 3.4; // Radio de la órbita
	const radiusTwo = 1.9; 
	const radiusThree = 3.7;
	const radiusFour = 3.2;


	const speed = 0.0040; 
	const speedtwo = 0.0070; 

	const angle = time * speed;
	const angleTwo = time * speedtwo;
	const angleThree = time * speed;
	const angleFour = time * speedtwo;


	torus.position.y = radiusTwo * Math.sin(angle);
	torus.position.x = radius * Math.cos(angle);
	torus.position.z = radius * Math.sin(angle);
	torusOne.position.y = radius * Math.sin(angleTwo);
	torusOne.position.x = radiusThree * Math.cos(angleTwo);
	torusThree.position.y = radiusTwo * Math.sin(-angle);
	torusThree.position.x = radiusTwo * Math.cos(-angle);
	torusThree.position.z = radiusTwo * Math.sin(-angle);
	torusFive.position.y = radiusTwo * Math.sin(angle);
	torusFive.position.x = radiusTwo * Math.cos(angle);
	torusSix.position.y = radiusThree * Math.sin(-angleTwo);
	torusSix.position.x = radiusThree * Math.cos(-angleTwo);
	torusSix.position.z = radiusThree * Math.sin(-angleTwo);
	torusSeven.position.x = radiusFour * Math.cos(angleThree);
	torusSeven.position.y = radiusFour * Math.sin(angleThree);
	torusSeven.position.z = radiusFour * Math.cos(angleThree);
	renderer.render( scene, camera );

    const shineIntensity = 0.05 + Math.sin(time / 1000) * 1.5; // Ajusta según sea necesario
    materialOne.specularIntensity = shineIntensity;
    material.specularIntensity = shineIntensity;
    materialone.specularIntensity = shineIntensity;
    materialfour.specularIntensity = shineIntensity;
    materialfive.specularIntensity = shineIntensity;
    materialSix.specularIntensity = shineIntensity;	

	deformGrid(time);
	}

    </script>
</body>
</html>
